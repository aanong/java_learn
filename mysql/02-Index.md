# MySQL Index (索引剖析)

索引 (Index) 是帮助 MySQL 高效获取数据的数据结构。

## 一、索引的数据结构

MySQL 主要使用 **B+树** 作为索引结构。

### 1. 为什么是 B+树？
- **哈希表**：适合等值查询，不适合范围查询。
- **二叉树/平衡二叉树 (AVL) / 红黑树**：树高过高，磁盘 IO 次数多。
- **B树**：每个节点都存 Key 和 Value。
- **B+树**：
    - **非叶子节点只存 Key**：同样大小的页可以存更多的索引，树更矮胖，IO 更少。
    - **叶子节点存 Key 和 Value**：所有数据都在叶子节点。
    - **叶子节点形成双向链表**：便于范围查询和排序。

### 2. Page 页
- InnoDB 管理存储空间的基本单位是 **页 (Page)**，默认 16KB。
- B+树的每个节点就是一个页。

## 二、索引分类 (InnoDB)

### 1. 主键索引 (聚簇索引 / Clustered Index)
- **定义**：叶子节点存储了 **整行数据**。
- **特点**：一张表只能有一个聚簇索引。
- **选择规则**：
    1. 优先选择主键。
    2. 没有主键，选择第一个非空的唯一索引。
    3. 都没有，InnoDB 生成一个隐藏的 6 字节 row_id。

### 2. 二级索引 (非聚簇索引 / Secondary Index)
- **定义**：叶子节点存储了 **索引列的值** 和 **主键值**。
- **特点**：包括普通索引、唯一索引、联合索引。
- **回表 (Back Query)**：
    - 如果查询的列在二级索引中找不到，需要拿主键值去聚簇索引中再查一次，称为回表。
    - 例：`select * from user where name = 'Alice';` (name 是索引)
    - 过程：先查 name 索引找到 id，再根据 id 查聚簇索引找到整行数据。

### 3. 联合索引 (Composite Index)
- **定义**：基于多个列创建的索引。
- **结构**：先按第一列排序，第一列相同按第二列排序...
- **最左前缀原则 (Leftmost Prefix Principle)**：
    - 必须从最左边的列开始匹配。
    - 如果中间跳过某列，后面的列索引失效。
    - 遇到范围查询 (`>`, `<`, `between`, `like`)，右边的列索引失效。

## 三、索引优化与概念

### 1. 覆盖索引 (Covering Index)
- 查询的列完全被索引包含，**不需要回表**。
- 例：`select id, name from user where name = 'Alice';` (name 是索引，叶子节点有 name 和 id)

### 2. 索引下推 (Index Condition Pushdown - ICP)
- MySQL 5.6 引入。
- 在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 3. 怎么判断一条 SQL 走没走索引？
- 使用 `explain` 命令查看执行计划（详见下一章）。
