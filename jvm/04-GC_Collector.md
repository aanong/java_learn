# GC Collectors (垃圾收集器)

JVM 提供了多种垃圾收集器，可以根据具体应用场景选择合适的组合。

![GC Collectors](https://img-blog.csdnimg.cn/20210508160840582.png)
*(图示：连线表示可以搭配使用)*

## 一、经典垃圾收集器

### 1. Serial 收集器
- **特点**：单线程、简单高效。
- **工作方式**：进行垃圾收集时，必须暂停其他所有工作线程 (Stop The World)，直到收集结束。
- **适用场景**：Client 模式下的虚拟机；内存小的应用。
- **算法**：新生代采用复制算法，老年代采用标记-整理算法。

### 2. ParNew 收集器
- **特点**：Serial 收集器的多线程并行版本。
- **适用场景**：它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，因为除了 Serial 外，只有它能与 CMS 收集器配合工作。
- **算法**：新生代采用复制算法。

### 3. Parallel Scavenge 收集器
- **特点**：也是新生代收集器，基于复制算法，并行的。
- **关注点**：**吞吐量 (Throughput)**。吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。
- **适用场景**：后台运算而不需要太多交互的任务。
- **常用参数**：
    - `-XX:MaxGCPauseMillis`：控制最大垃圾收集停顿时间。
    - `-XX:GCTimeRatio`：设置吞吐量大小。

### 4. Serial Old 收集器
- **特点**：Serial 收集器的老年代版本，单线程。
- **算法**：标记-整理算法。
- **适用场景**：Client 模式；在 Server 模式下主要作为 CMS 收集器的后备预案。

### 5. Parallel Old 收集器
- **特点**：Parallel Scavenge 收集器的老年代版本，多线程。
- **算法**：标记-整理算法。
- **适用场景**：注重吞吐量及 CPU 资源敏感的场合。

### 6. CMS (Concurrent Mark Sweep) 收集器
- **特点**：以获取 **最短回收停顿时间** 为目标。并发收集、低停顿。
- **算法**：**标记-清除** 算法。
- **运作过程**：
    1. **初始标记 (Initial Mark)**：标记 GC Roots 能直接关联到的对象，速度快，需要 STW。
    2. **并发标记 (Concurrent Mark)**：从 GC Roots 的直接关联对象开始遍历整个对象图，耗时长，但不需要 STW。
    3. **重新标记 (Remark)**：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要 STW。
    4. **并发清除 (Concurrent Sweep)**：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。
- **缺点**：
    - 对 CPU 资源敏感。
    - 无法处理 **浮动垃圾** (Floating Garbage)。
    - **标记-清除** 算法会导致大量空间碎片。

### 7. G1 (Garbage First) 收集器
- **特点**：面向服务端应用，旨在替代 CMS。可以指定最大停顿时间。
- **内存布局**：不再坚持固定大小和固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域 (**Region**)。每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。
- **运作过程**：
    1. **初始标记**
    2. **并发标记**
    3. **最终标记**
    4. **筛选回收**：对各个 Region 的回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划。
- **优势**：
    - **并行与并发**。
    - **分代收集**。
    - **空间整合**：整体基于标记-整理，局部基于复制，无内存碎片。
    - **可预测的停顿**。

## 二、现代垃圾收集器 (了解)

### 8. ZGC
- **目标**：在对吞吐量影响不大的前提下，实现任意堆内存大小下都可以把垃圾收集的停顿时间限制在 10ms 以内。
- **特点**：基于 **Region** 内存布局，不设分代，使用了 **读屏障**、**染色指针** 和 **内存多重映射** 等技术来实现可并发的标记-整理算法。

### 9. Shenandoah
- OpenJDK 只有 Shenandoah，Oracle JDK 没有。
- 目标与 ZGC 类似。

## 三、垃圾收集器总结

| 收集器 | 串行/并行/并发 | 新生代/老年代 | 算法 | 目标 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Serial** | 串行 | 新生代 | 复制 | 响应速度优先 | 单 CPU 环境，Client 模式 |
| **Serial Old** | 串行 | 老年代 | 标记-整理 | 响应速度优先 | 单 CPU 环境，Client 模式 |
| **ParNew** | 并行 | 新生代 | 复制 | 响应速度优先 | 多 CPU 环境，配合 CMS |
| **Parallel Scavenge** | 并行 | 新生代 | 复制 | 吞吐量优先 | 后台运算，交互少 |
| **Parallel Old** | 并行 | 老年代 | 标记-整理 | 吞吐量优先 | 后台运算，交互少 |
| **CMS** | 并发 | 老年代 | 标记-清除 | 响应速度优先 | 互联网应用，B/S 系统 |
| **G1** | 并发 | Both | 标记-整理 + 复制 | 响应速度优先 | 面向服务端，大内存 |
