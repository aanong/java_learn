# GC Algorithms (垃圾回收算法)

## 一、如何确定垃圾

在进行垃圾回收之前，首先要确定哪些对象是"垃圾"（即不再被使用的对象）。

### 1. 引用计数法 (Reference Counting)
- **原理**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；引用失效时，计数器减1。计数器为0的对象就是不可能再被使用的。
- **优点**：实现简单，判定效率高。
- **缺点**：**很难解决对象之间相互循环引用的问题**。
    - 例：objA.instance = objB; objB.instance = objA; 即使这两个对象都不再被访问，计数器也不为0。
    - **Java 虚拟机未采用此算法**。

### 2. 可达性分析算法 (Reachability Analysis)
- **原理**：通过一系列称为 "GC Roots" 的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索。如果某个对象到 GC Roots 间没有任何引用链相连（即不可达），则证明此对象是不可用的。
- **GC Roots 对象包括**：
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
    - 方法区中类静态属性引用的对象。
    - 方法区中常量引用的对象。
    - 本地方法栈中 JNI (Native 方法) 引用的对象。
    - Java 虚拟机内部的引用（如基本数据类型对应的 Class 对象，一些常驻异常对象）。
    - 所有被同步锁 (synchronized 关键字) 持有的对象。

## 二、垃圾收集算法

### 1. 标记-清除算法 (Mark-Sweep)
- **过程**：
    1. **标记**：标记出所有需要回收的对象。
    2. **清除**：统一回收所有被标记的对象。
- **缺点**：
    1. **执行效率不稳定**：如果对象数量多，标记和清除的效率都不高。
    2. **内存碎片**：清除后会产生大量不连续的内存碎片，可能导致后续分配大对象时无法找到足够的连续内存而触发另一次 GC。

### 2. 标记-复制算法 (Mark-Copying)
- **原理**：将内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
- **应用**：主要用于 **新生代**。
- **优化**：并不需要 1:1 划分。HotSpot 虚拟机将新生代分为一块较大的 **Eden** 空间和两块较小的 **Survivor** 空间 (S0, S1)，默认比例 8:1:1。每次分配内存只使用 Eden 和其中一块 Survivor。
- **优点**：实现简单，运行高效，无内存碎片。
- **缺点**：可用内存缩小为原来的一半（如果不优化）。

### 3. 标记-整理算法 (Mark-Compact)
- **原理**：标记过程与"标记-清除"一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
- **应用**：主要用于 **老年代**。
- **优点**：解决了内存碎片问题。
- **缺点**：移动对象需要暂停用户线程 (Stop The World)，效率较低。

### 4. 分代收集算法 (Generational Collection)
- **核心思想**：根据对象存活周期的不同将内存分为几块。一般是把 Java 堆分为 **新生代** 和 **老年代**。
- **策略**：
    - **新生代**：对象存活率低，选用 **复制算法**。
    - **老年代**：对象存活率高、没有额外空间进行分配担保，选用 **标记-清除** 或 **标记-整理** 算法。
